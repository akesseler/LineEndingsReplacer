/*
 * MIT License
 * 
 * Copyright (c) 2020 plexdata.de
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

using NUnit.Framework;
using Plexdata.LineEndingsReplacer.Entities;
using Plexdata.LineEndingsReplacer.Extensions;
using Plexdata.LineEndingsReplacer.Processing;
using System;
using System.Collections;
using System.Diagnostics.CodeAnalysis;
using System.IO;
using System.Linq;
using System.Threading;

namespace LineEndingsReplacerTests.Processing
{
    [SuppressMessage("Style", "IDE0060:Remove unused parameter", Justification = "<Pending>")]
    [SuppressMessage("CodeQuality", "IDE0079:Remove unnecessary suppression", Justification = "<Pending>")]
    public class FileProcessorTests
    {
        // UTF-8         : NOTHING     => '\r' = 0d          | '\n' = 0a
        // UTF-8-BOM     : EF BB BF    => '\r' = 0d          | '\n' = 0a
        // UTF-16-BOM-LE : FF FE       => '\r' = 0d 00       | '\n' = 0a 00  
        // UTF-16-BOM-BE : FE FF       => '\r' = 00 0d       | '\n' = 00 0a  
        // UTF-32-BOM-LE : FF FE 00 00 => '\r' = 0d 00 00 00 | '\n' = 0a 00 00 00  
        // UTF-32-BOM-BE : 00 00 FE FF => '\r' = 00 00 00 0d | '\n' = 00 00 00 0a (guess)

        [Test]
        public void Process_FileInfoSourceIsNull_ThrowsArgumentNullException()
        {
            String target = Path.GetTempFileName();

            try
            {
                FileProcessor processor = new FileProcessor();

                Assert.That(() => processor.Process(new CancellationToken(false), null, new FileInfo(target), "\r"), Throws.ArgumentNullException);
            }
            finally
            {
                File.Delete(target);
            }
        }

        [Test]
        public void Process_FileInfoTargetIsNull_ThrowsArgumentNullException()
        {
            String source = Path.GetTempFileName();

            try
            {
                FileProcessor processor = new FileProcessor();

                Assert.That(() => processor.Process(new CancellationToken(false), new FileInfo(source), null, "\r"), Throws.ArgumentNullException);
            }
            finally
            {
                File.Delete(source);
            }
        }

        [TestCase(null)]
        [TestCase("")]
        [TestCase("  ")]
        public void Process_FileInfoEndingIsInvalid_ThrowsArgumentOutOfRangeException(String ending)
        {
            String source = Path.GetTempFileName();
            String target = Path.GetTempFileName();

            try
            {
                FileProcessor processor = new FileProcessor();

                Assert.That(() => processor.Process(new CancellationToken(false), new FileInfo(source), new FileInfo(target), ending), Throws.InstanceOf<ArgumentOutOfRangeException>());
            }
            finally
            {
                File.Delete(source);
                File.Delete(target);
            }
        }

        [Test]
        public void Process_StreamDetailsIsNull_ThrowsArgumentNullException()
        {
            FileProcessor processor = new FileProcessor();

            Assert.That(() => processor.Process(new CancellationToken(false), null, new MemoryStream(), new MemoryStream(), "\r"), Throws.ArgumentNullException);
        }

        [Test]
        public void Process_StreamSourceIsNull_ThrowsArgumentNullException()
        {
            FileProcessor processor = new FileProcessor();

            Assert.That(() => processor.Process(new CancellationToken(false), this.CreateFileDetails(new Byte[0]), null, new MemoryStream(), "\r"), Throws.ArgumentNullException);
        }

        [Test]
        public void Process_StreamTargetIsNull_ThrowsArgumentNullException()
        {
            FileProcessor processor = new FileProcessor();

            Assert.That(() => processor.Process(new CancellationToken(false), this.CreateFileDetails(new Byte[0]), new MemoryStream(), null, "\r"), Throws.ArgumentNullException);
        }

        [TestCase(null)]
        [TestCase("")]
        [TestCase("  ")]
        public void Process_StreamEndingIsInvalid_ThrowsArgumentOutOfRangeException(String ending)
        {
            FileProcessor processor = new FileProcessor();

            Assert.That(() => processor.Process(new CancellationToken(false), this.CreateFileDetails(new Byte[0]), new MemoryStream(), new MemoryStream(), ending), Throws.InstanceOf<ArgumentOutOfRangeException>());
        }

        [Test]
        public void Process_StreamSourceAndDetailsLengthMismatch_ThrowsArgumentOutOfRangeException()
        {
            FileProcessor processor = new FileProcessor();

            Assert.That(() => processor.Process(new CancellationToken(false), this.CreateFileDetails(new Byte[] { 0xFF, 0xFE }), new MemoryStream(new Byte[] { 0x01, 0x02, 0x03 }), new MemoryStream(), "\r"), Throws.InstanceOf<ArgumentOutOfRangeException>());
        }

        [Test]
        public void Process_ValuesValidButCancellationTokenIsTrue_ThrowsOperationCanceledException()
        {
            FileProcessor processor = new FileProcessor();

            Assert.That(() => processor.Process(new CancellationToken(true), this.CreateFileDetails(new Byte[] { 0x01, 0x02, 0x03 }), new MemoryStream(new Byte[] { 0x01, 0x02, 0x03 }), new MemoryStream(), "\r"), Throws.InstanceOf<OperationCanceledException>());
        }

        public static IEnumerable TestSourcesWithoutContent
        {
            get
            {
                yield return new TestCaseData("Empty with CR", "\r", new Byte[] { }, new Byte[] { });
                yield return new TestCaseData("Empty with LF", "\n", new Byte[] { }, new Byte[] { });
                yield return new TestCaseData("Empty with CR+LF", "\r\n", new Byte[] { }, new Byte[] { });
            }
        }

        [TestCaseSource(nameof(TestSourcesWithoutContent))]
        public void Process_TestSourcesWithoutContent_ResultAsExpected(String identifier, String ending, Byte[] buffer, Byte[] expected)
        {
            CancellationToken token = new CancellationToken(false);
            FileDetails details = this.CreateFileDetails(buffer);

            MemoryStream source = new MemoryStream(buffer);
            MemoryStream target = new MemoryStream();

            FileProcessor processor = new FileProcessor();

            processor.Process(token, details, source, target, ending);

            Assert.That(this.IsEqual(target, expected), Is.True);
        }

        public static IEnumerable TestSourcesWithoutLineEndings
        {
            get
            {
                #region UTF-8

                yield return new TestCaseData("UTF-8 with CR", "\r",
                    new Byte[] { 0x30, 0x31, 0x32 },
                    new Byte[] { 0x30, 0x31, 0x32 }
                );
                yield return new TestCaseData("UTF-8 with LF", "\n",
                    new Byte[] { 0x30, 0x31, 0x32 },
                    new Byte[] { 0x30, 0x31, 0x32 }
                );
                yield return new TestCaseData("UTF-8 with CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x31, 0x32 },
                    new Byte[] { 0x30, 0x31, 0x32 }
                );
                yield return new TestCaseData("UTF-8-BOM with CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x31, 0x32 },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x31, 0x32 }
                );
                yield return new TestCaseData("UTF-8-BOM with LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x31, 0x32 },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x31, 0x32 }
                );
                yield return new TestCaseData("UTF-8-BOM with CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x31, 0x32 },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x31, 0x32 }
                );

                #endregion

                #region UTF-16

                yield return new TestCaseData("UTF-16-BOM-LE with CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x31, 0x00, 0x32, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32 },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32 },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32 },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x31, 0x00, 0x32 }
                );

                #endregion

                #region UTF-32

                yield return new TestCaseData("UTF-32-BOM-LE with CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32 },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32 },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32 },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x32 }
                );

                #endregion
            }
        }

        [TestCaseSource(nameof(TestSourcesWithoutLineEndings))]
        public void Process_TestSourcesWithoutLineEndings_ResultAsExpected(String identifier, String ending, Byte[] buffer, Byte[] expected)
        {
            CancellationToken token = new CancellationToken(false);
            FileDetails details = this.CreateFileDetails(buffer);

            MemoryStream source = new MemoryStream(buffer);
            MemoryStream target = new MemoryStream();

            FileProcessor processor = new FileProcessor();

            processor.Process(token, details, source, target, ending);

            Assert.That(this.IsEqual(target, expected), Is.True);
        }

        public static IEnumerable TestSourcesWithSingleLineEndings
        {
            get
            {
                #region UTF-8

                yield return new TestCaseData("UTF-8 with CR into CR", "\r",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D },
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8 with LF into CR", "\r",
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8 with CR+LF into CR", "\r",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8-BOM with CR into CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8-BOM with LF into CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8-BOM with CR+LF into CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8 with CR into LF", "\n",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D },
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with LF into LF", "\n",
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with CR+LF into LF", "\n",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR into LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with LF into LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR+LF into LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with CR into CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D },
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with LF into CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR into CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with LF into CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );

                #endregion

                #region UTF-16

                yield return new TestCaseData("UTF-16-BOM-LE with CR into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR+LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR into CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with LF into CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR+LF into CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR+LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR into LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with LF into LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR+LF into LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR into CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with LF into CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A }
                );

                #endregion

                #region UTF-32

                yield return new TestCaseData("UTF-32-BOM-LE with CR into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR+LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR into CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with LF into CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR+LF into CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR+LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR into LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with LF into LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR+LF into LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR into CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with LF into CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A }
                );

                #endregion
            }
        }

        [TestCaseSource(nameof(TestSourcesWithSingleLineEndings))]
        public void Process_TestSourcesWithSingleLineEndings_ResultAsExpected(String identifier, String ending, Byte[] buffer, Byte[] expected)
        {
            CancellationToken token = new CancellationToken(false);
            FileDetails details = this.CreateFileDetails(buffer);

            MemoryStream source = new MemoryStream(buffer);
            MemoryStream target = new MemoryStream();

            FileProcessor processor = new FileProcessor();

            processor.Process(token, details, source, target, ending);

            Assert.That(this.IsEqual(target, expected), Is.True);
        }

        public static IEnumerable TestSourcesWithMultipleLineEndings
        {
            get
            {
                #region UTF-8

                yield return new TestCaseData("UTF-8 with CR into CR", "\r",
                    new Byte[] { 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D },
                    new Byte[] { 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D }
                );
                yield return new TestCaseData("UTF-8 with LF into CR", "\r",
                    new Byte[] { 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D }
                );
                yield return new TestCaseData("UTF-8 with CR+LF into CR", "\r",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D }
                );
                yield return new TestCaseData("UTF-8-BOM with CR into CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D }
                );
                yield return new TestCaseData("UTF-8-BOM with LF into CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D }
                );
                yield return new TestCaseData("UTF-8-BOM with CR+LF into CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D }
                );
                yield return new TestCaseData("UTF-8 with CR into LF", "\n",
                    new Byte[] { 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D },
                    new Byte[] { 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with LF into LF", "\n",
                    new Byte[] { 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A },
                    new Byte[] { 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with CR+LF into LF", "\n",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR into LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with LF into LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR+LF into LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with CR into CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D },
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with LF into CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR into CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0D, 0x31, 0x0D, 0x0D, 0x32, 0x0D, 0x0D },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with LF into CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x0A, 0x31, 0x0A, 0x0A, 0x32, 0x0A, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x0D, 0x0A, 0x32, 0x0D, 0x0A, 0x0D, 0x0A }
                );

                #endregion

                #region UTF-16

                yield return new TestCaseData("UTF-16-BOM-LE with CR into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR+LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR into CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with LF into CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR+LF into CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR+LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR into LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with LF into LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR+LF into LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR into CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0D },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with LF into CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x0D, 0x00, 0x0A }
                );

                #endregion

                #region UTF-32

                yield return new TestCaseData("UTF-32-BOM-LE with CR into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR+LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR into CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with LF into CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR+LF into CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR+LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR into LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with LF into LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR+LF into LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR into CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0D },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with LF into CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A }
                );

                #endregion
            }
        }

        [TestCaseSource(nameof(TestSourcesWithMultipleLineEndings))]
        public void Process_TestSourcesWithMultipleLineEndings_ResultAsExpected(String identifier, String ending, Byte[] buffer, Byte[] expected)
        {
            CancellationToken token = new CancellationToken(false);
            FileDetails details = this.CreateFileDetails(buffer);

            MemoryStream source = new MemoryStream(buffer);
            MemoryStream target = new MemoryStream();

            FileProcessor processor = new FileProcessor();

            processor.Process(token, details, source, target, ending);

            Assert.That(this.IsEqual(target, expected), Is.True);
        }

        public static IEnumerable TestSourcesWithMixedLineEndings
        {
            get
            {
                #region UTF-8

                yield return new TestCaseData("UTF-8 with CR,LF,CR+LF into CR", "\r",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8-BOM with CR,LF,CR+LF into CR", "\r",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D }
                );
                yield return new TestCaseData("UTF-8 with CR,LF,CR+LF into LF", "\n",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR,LF,CR+LF into LF", "\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A }
                );
                yield return new TestCaseData("UTF-8 with CR,LF,CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );
                yield return new TestCaseData("UTF-8-BOM with CR,LF,CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0D, 0x0A },
                    new Byte[] { 0xEF, 0xBB, 0xBF, 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A }
                );

                #endregion

                #region UTF-16

                yield return new TestCaseData("UTF-16-BOM-LE with CR,LF,CR+LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR,LF,CR+LF into CR", "\r",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x32, 0x00, 0x0D }
                );

                yield return new TestCaseData("UTF-16-BOM-LE with CR,LF,CR+LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR,LF,CR+LF into LF", "\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-16-BOM-LE with CR,LF,CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A, 0x00 }
                );
                yield return new TestCaseData("UTF-16-BOM-BE with CR,LF,CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x31, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A },
                    new Byte[] { 0xFE, 0xFF, 0x00, 0x30, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x31, 0x00, 0x0D, 0x00, 0x0A, 0x00, 0x32, 0x00, 0x0D, 0x00, 0x0A }
                );

                #endregion

                #region UTF-32

                yield return new TestCaseData("UTF-32-BOM-LE with CR,LF,CR+LF into CR", "\r",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR,LF,CR+LF into CR", "\r",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR,LF,CR+LF into LF", "\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR,LF,CR+LF into LF", "\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0A }
                );
                yield return new TestCaseData("UTF-32-BOM-LE with CR,LF,CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 },
                    new Byte[] { 0xFF, 0xFE, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00 }
                );
                yield return new TestCaseData("UTF-32-BOM-BE with CR,LF,CR+LF into CR+LF", "\r\n",
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A },
                    new Byte[] { 0x00, 0x00, 0xFE, 0xFF, 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x31, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x32, 0x00, 0x00, 0x00, 0x0D, 0x00, 0x00, 0x00, 0x0A }
                );

                #endregion
            }
        }

        [TestCaseSource(nameof(TestSourcesWithMixedLineEndings))]
        public void Process_TestSourcesWithMixedLineEndings_ResultAsExpected(String identifier, String ending, Byte[] buffer, Byte[] expected)
        {
            CancellationToken token = new CancellationToken(false);
            FileDetails details = this.CreateFileDetails(buffer);

            MemoryStream source = new MemoryStream(buffer);
            MemoryStream target = new MemoryStream();

            FileProcessor processor = new FileProcessor();

            processor.Process(token, details, source, target, ending);

            Assert.That(this.IsEqual(target, expected), Is.True);
        }

        public static IEnumerable TestSourcesForTotalCountSmokeTests
        {
            get
            {
                yield return new TestCaseData("UTF-8 with 3xCR", "\r",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0D, 0x32, 0x0D },
                    new WorkResult(new Byte[] { 0x0D }, 3, 3, 0, 0)
                );
                yield return new TestCaseData("UTF-8 with 3xLF", "\r",
                    new Byte[] { 0x30, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new WorkResult(new Byte[] { 0x0D }, 3, 0, 3, 0)
                );
                yield return new TestCaseData("UTF-8 with 3xCR+LF", "\r",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0D, 0x0A, 0x32, 0x0D, 0x0A },
                    new WorkResult(new Byte[] { 0x0D }, 3, 0, 0, 3)
                );
                yield return new TestCaseData("UTF-8 with 1xCR, 2xLF", "\r",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0A },
                    new WorkResult(new Byte[] { 0x0D }, 3, 1, 2, 0)
                );
                yield return new TestCaseData("UTF-8 with 1xCR+LF, 2xLF", "\r",
                    new Byte[] { 0x30, 0x0D, 0x0A, 0x31, 0x0A, 0x32, 0x0A },
                    new WorkResult(new Byte[] { 0x0D }, 3, 0, 2, 1)
                );
                yield return new TestCaseData("UTF-8 with 1xCR, 1xLF, 1xCR+LF", "\r",
                    new Byte[] { 0x30, 0x0D, 0x31, 0x0A, 0x32, 0x0D, 0x0A },
                    new WorkResult(new Byte[] { 0x0D }, 3, 1, 1, 1)
                );
            }
        }

        [TestCaseSource(nameof(TestSourcesForTotalCountSmokeTests))]
        public void Process_TestSourcesForTotalCountSmokeTests_ResultAsExpected(String identifier, String ending, Byte[] buffer, WorkResult expected)
        {
            CancellationToken token = new CancellationToken(false);
            FileDetails details = this.CreateFileDetails(buffer);

            MemoryStream source = new MemoryStream(buffer);
            MemoryStream target = new MemoryStream();

            FileProcessor processor = new FileProcessor();

            WorkResult actual = processor.Process(token, details, source, target, ending);

            Assert.That(actual.ToString(), Is.EqualTo(expected.ToString()));
        }

        private Boolean IsEqual(MemoryStream actual, Byte[] expected)
        {
            return Enumerable.SequenceEqual(actual.ToArray(), expected);
        }

        private FileDetails CreateFileDetails(Byte[] buffer)
        {
            MemoryStream stream = new MemoryStream(buffer);

            return stream.GetDetails();
        }
    }
}
